// Safe configuration that works in both client and server environments
const config = {
  isDevelopment: typeof window !== 'undefined' ? true : (typeof process !== 'undefined' && process.env?.NODE_ENV === 'development'),
  isProduction: typeof window !== 'undefined' ? false : (typeof process !== 'undefined' && process.env?.NODE_ENV === 'production'),
  isTest: typeof window !== 'undefined' ? false : (typeof process !== 'undefined' && process.env?.NODE_ENV === 'test'),
};

export enum LogLevel {
  ERROR = 'error',
  WARN = 'warn',
  INFO = 'info',
  DEBUG = 'debug',
}

export interface LogEntry {
  timestamp: string;
  level: LogLevel;
  message: string;
  context?: Record<string, any>;
  userId?: string;
  requestId?: string;
  error?: {
    name: string;
    message: string;
    stack?: string;
  };
}

export class Logger {
  private static instance: Logger;
  private logLevel: LogLevel;

  private constructor() {
    this.logLevel = config.isDevelopment ? LogLevel.DEBUG : LogLevel.INFO;
  }

  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }

  private shouldLog(level: LogLevel): boolean {
    const levels = [LogLevel.ERROR, LogLevel.WARN, LogLevel.INFO, LogLevel.DEBUG];
    const currentLevelIndex = levels.indexOf(this.logLevel);
    const messageLevelIndex = levels.indexOf(level);
    return messageLevelIndex <= currentLevelIndex;
  }

  private formatLog(level: LogLevel, message: string, context?: Record<string, any>): LogEntry {
    return {
      timestamp: new Date().toISOString(),
      level,
      message,
      context,
    };
  }

  private output(entry: LogEntry): void {
    if (!this.shouldLog(entry.level)) return;

    const formattedMessage = `[${entry.timestamp}] ${entry.level.toUpperCase()}: ${entry.message}`;
    
    switch (entry.level) {
      case LogLevel.ERROR:
        console.error(formattedMessage, entry.context);
        break;
      case LogLevel.WARN:
        console.warn(formattedMessage, entry.context);
        break;
      case LogLevel.INFO:
        console.info(formattedMessage, entry.context);
        break;
      case LogLevel.DEBUG:
        console.debug(formattedMessage, entry.context);
        break;
    }

    // In production, send to external logging service
    if (config.isProduction) {
      this.sendToExternalService(entry);
    }
  }

  private async sendToExternalService(entry: LogEntry): Promise<void> {
    try {
      // TODO: Implement external logging service (e.g., Sentry, LogRocket, DataDog)
      // For now, we'll just log to console in production
      if (entry.level === LogLevel.ERROR) {
        console.error('Production Error:', entry);
      }
    } catch (error) {
      console.error('Failed to send log to external service:', error);
    }
  }

  error(message: string, context?: Record<string, any>, error?: Error): void {
    const entry = this.formatLog(LogLevel.ERROR, message, context);
    if (error) {
      entry.error = {
        name: error.name,
        message: error.message,
        stack: error.stack,
      };
    }
    this.output(entry);
  }

  warn(message: string, context?: Record<string, any>): void {
    const entry = this.formatLog(LogLevel.WARN, message, context);
    this.output(entry);
  }

  info(message: string, context?: Record<string, any>): void {
    const entry = this.formatLog(LogLevel.INFO, message, context);
    this.output(entry);
  }

  debug(message: string, context?: Record<string, any>): void {
    const entry = this.formatLog(LogLevel.DEBUG, message, context);
    this.output(entry);
  }

  // Performance logging
  performance(operation: string, duration: number, context?: Record<string, any>): void {
    this.info(`Performance: ${operation} took ${duration}ms`, {
      operation,
      duration,
      ...context,
    });
  }

  // Security logging
  security(event: string, context?: Record<string, any>): void {
    this.warn(`Security Event: ${event}`, {
      event,
      ...context,
    });
  }

  // API logging
  api(method: string, url: string, status: number, duration: number, context?: Record<string, any>): void {
    const level = status >= 400 ? LogLevel.ERROR : LogLevel.INFO;
    const entry = this.formatLog(level, `API ${method} ${url} - ${status}`, {
      method,
      url,
      status,
      duration,
      ...context,
    });
    this.output(entry);
  }

  // Database logging
  database(operation: string, collection: string, duration: number, context?: Record<string, any>): void {
    this.debug(`Database ${operation} on ${collection}`, {
      operation,
      collection,
      duration,
      ...context,
    });
  }
}

// Export singleton instance
export const logger = Logger.getInstance();

// Convenience functions
export const log = {
  error: (message: string, context?: Record<string, any>, error?: Error) => logger.error(message, context, error),
  warn: (message: string, context?: Record<string, any>) => logger.warn(message, context),
  info: (message: string, context?: Record<string, any>) => logger.info(message, context),
  debug: (message: string, context?: Record<string, any>) => logger.debug(message, context),
  performance: (operation: string, duration: number, context?: Record<string, any>) => logger.performance(operation, duration, context),
  security: (event: string, context?: Record<string, any>) => logger.security(event, context),
  api: (method: string, url: string, status: number, duration: number, context?: Record<string, any>) => logger.api(method, url, status, duration, context),
  database: (operation: string, collection: string, duration: number, context?: Record<string, any>) => logger.database(operation, collection, duration, context),
};
